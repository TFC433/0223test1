/**
 * data/announcement-sql-writer.js
 * [Strict Digital Forensics Mode]
 * - Type: SQL Writer
 * - Target: PostgreSQL (Supabase)
 * - Table: announcements
 * - Version: 1.0.0
 * - Date: 2026-02-05
 * - Description: Handles CUD operations for Announcements. STRICTLY enforces Service-generated IDs.
 */

const { supabase } = require('../config/supabase');

class AnnouncementSqlWriter {

    constructor() {
        this.tableName = 'announcements';
    }

    /**
     * Create a new announcement
     * @param {Object} data - DTO containing { id, title, content, status, isPinned, ... }
     * @param {string} creator - Creator display name
     * @returns {Promise<Object>} { success: true, id }
     */
    async createAnnouncement(data, creator) {
        // [Strict Rule] ID must be generated by the Service layer, not the DB
        if (!data.id) {
            throw new Error('[AnnouncementSqlWriter] Forbidden: Missing required "id". ID must be generated by Service.');
        }

        console.log(`ðŸ“¢ [AnnouncementSqlWriter] Creating: ${data.title} (ID: ${data.id})`);

        const now = new Date().toISOString();

        const row = {
            id: data.id,
            title: data.title,
            content: data.content || '',
            creator: creator,
            create_time: now,
            last_update_time: now,
            status: data.status || 'å·²ç™¼å¸ƒ',
            is_pinned: data.isPinned === true // Boolean enforcement
        };

        const { error } = await supabase
            .from(this.tableName)
            .insert([row]);

        if (error) {
            console.error('[AnnouncementSqlWriter] Create Failed:', error);
            throw new Error(`DB Insert Error: ${error.message}`);
        }

        return { success: true, id: data.id };
    }

    /**
     * Update an existing announcement
     * @param {string} id - Target ID
     * @param {Object} data - Partial update DTO
     * @param {string} modifier - Modifier display name
     * @returns {Promise<Object>} { success: true }
     */
    async updateAnnouncement(id, data, modifier) {
        if (!id) throw new Error('[AnnouncementSqlWriter] Update requires ID');

        console.log(`ðŸ“¢ [AnnouncementSqlWriter] Updating: ${id} by ${modifier}`);

        const now = new Date().toISOString();
        const updates = {
            last_update_time: now
        };

        // Map DTO fields to DB columns if present
        if (data.title !== undefined) updates.title = data.title;
        if (data.content !== undefined) updates.content = data.content;
        if (data.status !== undefined) updates.status = data.status;
        if (data.isPinned !== undefined) updates.is_pinned = data.isPinned;
        
        // Note: 'modifier' is typically logged to audit logs, but simplified schema usually tracks last_update_time.
        // If schema supported 'last_modifier', we would add it here.

        const { error } = await supabase
            .from(this.tableName)
            .update(updates)
            .eq('id', id);

        if (error) {
            console.error('[AnnouncementSqlWriter] Update Failed:', error);
            throw new Error(`DB Update Error: ${error.message}`);
        }

        return { success: true };
    }

    /**
     * Delete an announcement
     * @param {string} id 
     * @returns {Promise<Object>} { success: true }
     */
    async deleteAnnouncement(id) {
        if (!id) throw new Error('[AnnouncementSqlWriter] Delete requires ID');

        console.log(`ðŸ“¢ [AnnouncementSqlWriter] Deleting: ${id}`);

        const { error } = await supabase
            .from(this.tableName)
            .delete()
            .eq('id', id);

        if (error) {
            console.error('[AnnouncementSqlWriter] Delete Failed:', error);
            throw new Error(`DB Delete Error: ${error.message}`);
        }

        return { success: true };
    }
}

module.exports = AnnouncementSqlWriter;